<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>FaceCraft 3D Viewer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #1a1a2e; font-family: sans-serif; }
        #container { width: 100vw; height: 100vh; position: relative; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; text-align: center; z-index: 10; }
        .spinner { width: 30px; height: 30px; border: 2px solid rgba(255,255,255,0.1); border-top-color: #9A64DE; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 10px; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading"><div class="spinner"></div></div>
    </div>

    <!-- Three.js and Loaders -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/fflate.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        const Android = window.AndroidBridge || { log: console.log, error: console.error, onModelLoaded: () => {} };
        let scene, camera, renderer, controls, currentModel = null;
        let allMeshes = [];
        let currentMorphValues = {};

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x161625); // Deep Grey-Purple

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 0, 150);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.target.set(0, 0, 0);

            // Grid Helper (Blender Style)
            const gridColor = new THREE.Color(0x9A64DE).multiplyScalar(0.2);
            const grid = new THREE.GridHelper(400, 40, gridColor, 0x2a2a3a);
            grid.position.y = -50; // Below the model
            scene.add(grid);

            // Polar Grid for vertical alignment feel
            const polarGrid = new THREE.PolarGridHelper(200, 16, 8, 64, 0x2a2a3a, 0x1a1a2a);
            polarGrid.rotation.x = Math.PI / 2;
            polarGrid.position.z = -50;
            scene.add(polarGrid);

            // Lighting
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);
            const directional = new THREE.DirectionalLight(0xffffff, 0.8);
            directional.position.set(50, 100, 50);
            scene.add(directional);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            animate();
            loadTemplateModel('ally');
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function loadModel(path) {
            Android.log('Loading FBX: ' + path);
            document.getElementById('loading').style.display = 'block';

            if (currentModel) scene.remove(currentModel);
            allMeshes = [];

            const loader = new THREE.FBXLoader();
            loader.load(path, (object) => {
                currentModel = object;
                object.traverse((child) => {
                    if (child.isMesh) {
                        allMeshes.push(child);
                        if (child.geometry.attributes.position) {
                            child.userData.originalPositions = child.geometry.attributes.position.array.slice();
                        }
                    }
                });

                // Auto-center and scale
                const box = new THREE.Box3().setFromObject(object);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());
                const scale = 100 / Math.max(size.x, size.y, size.z); // Increased scale slightly
                object.scale.setScalar(scale);
                object.position.sub(center.multiplyScalar(scale));

                scene.add(object);
                document.getElementById('loading').style.display = 'none';
                Android.log('FBX Loaded: ' + path);
                Android.onModelLoaded();
            }, undefined, (err) => {
                Android.error('FBX Load Error: ' + err.message);
            });
        }

        function loadTemplateModel(name) {
            const path = 'models/' + name + '/scene.fbx';
            loadModel(path);
        }

        function animateMorphs(params) {
            currentMorphValues = { ...currentMorphValues, ...params };
            for (const mesh of allMeshes) {
                if (!mesh.userData.originalPositions) continue;
                const positions = mesh.geometry.attributes.position;
                const original = mesh.userData.originalPositions;
                const current = new Float32Array(original);

                // Procedural vertex scaling
                for (const [key, val] of Object.entries(currentMorphValues)) {
                    const factor = val - 1.0;
                    for (let i = 0; i < current.length; i += 3) {
                        // Very basic procedural deformation
                        if (key === 'faceWidth' && Math.abs(current[i]) > 5) current[i] *= (1 + factor * 0.1);
                        if (key === 'eyeSize' && current[i+1] > 40 && Math.abs(current[i]) > 5) current[i+1] *= (1 + factor * 0.05);
                    }
                }

                for (let i = 0; i < positions.count; i++) {
                    positions.setXYZ(i, current[i*3], current[i*3+1], current[i*3+2]);
                }
                positions.needsUpdate = true;
            }
        }

        function resetMorphs() {
            currentMorphValues = {};
            for (const mesh of allMeshes) {
                if (mesh.userData.originalPositions) {
                    const positions = mesh.geometry.attributes.position;
                    const original = mesh.userData.originalPositions;
                    for (let i = 0; i < positions.count; i++) {
                        positions.setXYZ(i, original[i*3], original[i*3+1], original[i*3+2]);
                    }
                    positions.needsUpdate = true;
                }
            }
        }

        window.onload = init;
        window.loadTemplateModel = loadTemplateModel;
        window.applyMorphs = animateMorphs;
        window.animateMorphs = animateMorphs;
        window.resetMorphs = resetMorphs;
    </script>
</body>
</html>
