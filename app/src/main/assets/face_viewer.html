<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>FaceCraft 3D Viewer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #1a1a2e; font-family: sans-serif; }
        #container { width: 100vw; height: 100vh; position: relative; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; text-align: center; z-index: 10; }
        .spinner { width: 30px; height: 30px; border: 2px solid rgba(255,255,255,0.1); border-top-color: #9A64DE; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 10px; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading"><div class="spinner"></div></div>
    </div>

    <!-- Three.js and Loaders -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/fflate.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        const Android = window.AndroidBridge || {
            log: console.log, error: console.error,
            onModelLoaded: function(){}, onModelLoadError: function(){}, onMorphApplied: function(){},
            onParameterChanged: function(){}, onScreenshotReady: function(){}, onCurrentMorphs: function(){},
            onBlendShapeNames: function(json){ console.log("BlendShape names:", json); }
        };

        let scene, camera, renderer, controls, currentModel = null;
        let allMeshes = [];
        let headMesh = null; // mesh with morph targets (blendshapes)
        let currentMorphValues = {};

        // Animation state for blendshape interpolation
        let animFrameId = null;
        let animStartTime = null;
        let animDuration = 500;
        let animFromInfluences = null; // {name: value} snapshot at anim start
        let animToInfluences = null;   // {name: value} target values

        // Default camera
        const DEFAULT_CAM = { x: 0, y: 0, z: 150 };

        // =============================================
        // Math helpers
        // =============================================
        function clamp01(x) { return x < 0 ? 0 : x > 1 ? 1 : x; }

        // =============================================
        // Find the mesh with the most morph targets
        // =============================================
        function findMorphMesh(root) {
            var best = null;
            var bestCount = -1;
            root.traverse(function(child) {
                if (!(child.isMesh || child.isSkinnedMesh)) return;
                var dict = child.morphTargetDictionary;
                var count = dict ? Object.keys(dict).length : 0;
                if (count > bestCount) { bestCount = count; best = child; }
            });
            return (bestCount > 0) ? best : null;
        }

        // =============================================
        // Get current blendshape influence by name
        // =============================================
        function getInfluence(name) {
            if (!headMesh || !headMesh.morphTargetDictionary || !headMesh.morphTargetInfluences) return 0;
            var idx = headMesh.morphTargetDictionary[name];
            if (idx === undefined) return 0;
            return headMesh.morphTargetInfluences[idx];
        }

        // =============================================
        // Snapshot all current influences as {name: value}
        // =============================================
        function snapshotInfluences() {
            var snap = {};
            if (!headMesh || !headMesh.morphTargetDictionary || !headMesh.morphTargetInfluences) return snap;
            var dict = headMesh.morphTargetDictionary;
            for (var name in dict) {
                snap[name] = headMesh.morphTargetInfluences[dict[name]];
            }
            return snap;
        }

        // =============================================
        // Apply morphs instantly (no animation)
        // =============================================
        function applyMorphsImmediate(params) {
            if (!headMesh || !headMesh.morphTargetDictionary || !headMesh.morphTargetInfluences) return;

            for (var name in params) {
                var idx = headMesh.morphTargetDictionary[name];
                if (idx === undefined) {
                    Android.log('Unknown blendshape: ' + name);
                    continue;
                }
                headMesh.morphTargetInfluences[idx] = clamp01(params[name]);
                currentMorphValues[name] = clamp01(params[name]);
            }
            Android.onMorphApplied();
        }

        // =============================================
        // Animate morphs smoothly over duration
        // =============================================
        function animateMorphsSmooth(params, duration) {
            if (!headMesh || !headMesh.morphTargetDictionary || !headMesh.morphTargetInfluences) return;

            duration = (typeof duration === 'number' && duration > 0) ? duration : 500;

            // Snapshot current state for all keys we're going to animate
            animFromInfluences = {};
            animToInfluences = {};
            for (var name in params) {
                if (headMesh.morphTargetDictionary[name] === undefined) {
                    Android.log('Unknown blendshape: ' + name);
                    continue;
                }
                animFromInfluences[name] = getInfluence(name);
                animToInfluences[name] = clamp01(params[name]);
            }

            // Update target morph values
            for (var name in animToInfluences) {
                currentMorphValues[name] = animToInfluences[name];
            }

            animDuration = duration;
            animStartTime = performance.now();

            if (animFrameId) cancelAnimationFrame(animFrameId);
            animFrameId = requestAnimationFrame(animStep);
        }

        function animStep(timestamp) {
            if (animStartTime === null) return;
            var elapsed = timestamp - animStartTime;
            var t = Math.min(elapsed / animDuration, 1.0);
            var eased = t * t * (3 - 2 * t); // smoothstep easing

            var dict = headMesh.morphTargetDictionary;

            for (var name in animToInfluences) {
                var idx = dict[name];
                if (idx === undefined) continue;
                var from = animFromInfluences[name];
                var to = animToInfluences[name];
                headMesh.morphTargetInfluences[idx] = from + (to - from) * eased;
            }

            if (t < 1.0) {
                animFrameId = requestAnimationFrame(animStep);
            } else {
                animFrameId = null;
                animStartTime = null;
                animFromInfluences = null;
                animToInfluences = null;
                Android.onMorphApplied();
            }
        }

        // =============================================
        // Reset morphs back to default (all influences = 0)
        // =============================================
        function resetMorphs() {
            currentMorphValues = {};
            if (!headMesh || !headMesh.morphTargetInfluences) return;
            for (var i = 0; i < headMesh.morphTargetInfluences.length; i++) {
                headMesh.morphTargetInfluences[i] = 0;
            }
        }

        // =============================================
        // Set a single morph parameter
        // =============================================
        function setMorph(name, value) {
            var p = {};
            p[name] = value;
            applyMorphsImmediate(p);
        }

        // =============================================
        // Get current morph values
        // =============================================
        function getCurrentMorphs() {
            Android.onCurrentMorphs(JSON.stringify(currentMorphValues));
        }

        // =============================================
        // Get blendshape names
        // =============================================
        function getBlendShapeNames() {
            if (!headMesh || !headMesh.morphTargetDictionary) {
                Android.onBlendShapeNames(JSON.stringify([]));
                return;
            }
            Android.onBlendShapeNames(JSON.stringify(Object.keys(headMesh.morphTargetDictionary)));
        }

        // =============================================
        // Camera controls
        // =============================================
        function setCameraPosition(x, y, z) {
            camera.position.set(x, y, z);
            camera.lookAt(controls.target);
        }

        function focusOnRegion(region) {
            var pos = { x: 0, y: 0, z: 100 };
            switch (region) {
                case 'eyes':     pos = { x: 0, y: 15, z: 80 }; break;
                case 'nose':     pos = { x: 0, y: 0, z: 70 };  break;
                case 'mouth':    pos = { x: 0, y: -10, z: 75 }; break;
                case 'jaw':      pos = { x: 0, y: -20, z: 90 }; break;
                case 'forehead': pos = { x: 0, y: 25, z: 85 }; break;
                case 'cheeks':   pos = { x: 20, y: 5, z: 80 }; break;
            }
            camera.position.set(pos.x, pos.y, pos.z);
            camera.lookAt(controls.target);
        }

        function resetCamera() {
            camera.position.set(DEFAULT_CAM.x, DEFAULT_CAM.y, DEFAULT_CAM.z);
            controls.target.set(0, 0, 0);
            camera.lookAt(controls.target);
        }

        // =============================================
        // Screenshot
        // =============================================
        function takeScreenshot() {
            renderer.render(scene, camera);
            var dataUrl = renderer.domElement.toDataURL('image/png');
            Android.onScreenshotReady(dataUrl);
        }

        // =============================================
        // Visual settings
        // =============================================
        function setBackgroundColor(color) {
            scene.background = new THREE.Color(color);
        }

        function setWireframe(enabled) {
            for (var i = 0; i < allMeshes.length; i++) {
                if (allMeshes[i].material) {
                    if (Array.isArray(allMeshes[i].material)) {
                        allMeshes[i].material.forEach(function(m) { m.wireframe = enabled; });
                    } else {
                        allMeshes[i].material.wireframe = enabled;
                    }
                }
            }
        }

        function setOrbitControls(enabled) {
            controls.enabled = enabled;
        }

        // =============================================
        // Scene initialization
        // =============================================
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x161625);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(DEFAULT_CAM.x, DEFAULT_CAM.y, DEFAULT_CAM.z);

            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.target.set(0, 0, 0);

            // Grid helpers
            var gridColor = new THREE.Color(0x9A64DE).multiplyScalar(0.2);
            var grid = new THREE.GridHelper(400, 40, gridColor, 0x2a2a3a);
            grid.position.y = -50;
            scene.add(grid);

            var polarGrid = new THREE.PolarGridHelper(200, 16, 8, 64, 0x2a2a3a, 0x1a1a2a);
            polarGrid.rotation.x = Math.PI / 2;
            polarGrid.position.z = -50;
            scene.add(polarGrid);

            // Lighting
            var ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);
            var directional = new THREE.DirectionalLight(0xffffff, 0.8);
            directional.position.set(50, 100, 50);
            scene.add(directional);

            window.addEventListener('resize', function() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            animate();
            loadTemplateModel('ally');
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // =============================================
        // Model loading
        // =============================================
        function loadModel(path) {
            Android.log('Loading FBX: ' + path);
            document.getElementById('loading').style.display = 'block';

            if (currentModel) scene.remove(currentModel);
            allMeshes = [];
            headMesh = null;
            currentMorphValues = {};

            var loader = new THREE.FBXLoader();
            loader.load(path, function(object) {
                currentModel = object;

                // Gather all meshes
                object.traverse(function(child) {
                    if (child.isMesh || child.isSkinnedMesh) {
                        allMeshes.push(child);
                    }
                });

                // Auto-center and scale
                var box = new THREE.Box3().setFromObject(object);
                var size = box.getSize(new THREE.Vector3());
                var center = box.getCenter(new THREE.Vector3());
                var scale = 100 / Math.max(size.x, size.y, size.z);
                object.scale.setScalar(scale);
                object.position.sub(center.multiplyScalar(scale));

                scene.add(object);

                // Find the mesh with morph targets (blendshapes)
                headMesh = findMorphMesh(object);

                if (headMesh && headMesh.morphTargetDictionary) {
                    var names = Object.keys(headMesh.morphTargetDictionary);
                    Android.log('Blendshapes found on "' + (headMesh.name || 'unnamed') + '": ' + names.length);
                    Android.log('Blendshape names: ' + JSON.stringify(names));
                    // Report blendshape names to Android
                    Android.onBlendShapeNames(JSON.stringify(names));
                } else {
                    Android.log('No blendshapes found in model');
                    Android.onBlendShapeNames(JSON.stringify([]));
                }

                document.getElementById('loading').style.display = 'none';
                Android.log('FBX Loaded: ' + path + ' | Meshes: ' + allMeshes.length);

                // Auto-diagnose model capabilities
                diagnoseModel();

                Android.onModelLoaded();
            }, undefined, function(err) {
                Android.error('FBX Load Error: ' + (err.message || err));
                Android.onModelLoadError('FBX Load Error: ' + (err.message || err));
                document.getElementById('loading').style.display = 'none';
            });
        }

        function loadTemplateModel(name) {
            var path = 'models/' + name + '/scene.fbx';
            loadModel(path);
        }

        // =============================================
        // Init on load
        // =============================================
        window.onload = init;

        // =============================================
        // Diagnostic: Report model capabilities
        // =============================================
        function diagnoseModel() {
            var report = {
                meshes: [],
                bones: [],
                skinnedMeshes: [],
                totalVertices: 0,
                hasSkeleton: false
            };

            if (!currentModel) {
                Android.log('DIAG: No model loaded');
                return report;
            }

            currentModel.traverse(function(child) {
                // Check for bones
                if (child.isBone) {
                    report.bones.push({
                        name: child.name,
                        parent: child.parent ? child.parent.name : null
                    });
                    report.hasSkeleton = true;
                }

                // Check meshes
                if (child.isMesh || child.isSkinnedMesh) {
                    var meshInfo = {
                        name: child.name,
                        type: child.isSkinnedMesh ? 'SkinnedMesh' : 'Mesh',
                        vertexCount: 0,
                        hasGeometry: false,
                        canModifyVertices: false,
                        morphTargetCount: 0
                    };

                    if (child.geometry) {
                        meshInfo.hasGeometry = true;
                        if (child.geometry.attributes && child.geometry.attributes.position) {
                            meshInfo.vertexCount = child.geometry.attributes.position.count;
                            meshInfo.canModifyVertices = true;
                            report.totalVertices += meshInfo.vertexCount;
                        }
                    }

                    if (child.morphTargetDictionary) {
                        meshInfo.morphTargetCount = Object.keys(child.morphTargetDictionary).length;
                    }

                    if (child.isSkinnedMesh) {
                        report.skinnedMeshes.push(meshInfo);
                        if (child.skeleton) {
                            meshInfo.boneCount = child.skeleton.bones.length;
                        }
                    }

                    report.meshes.push(meshInfo);
                }
            });

            // Log summary
            Android.log('=== MODEL DIAGNOSIS ===');
            Android.log('Total meshes: ' + report.meshes.length);
            Android.log('Skinned meshes: ' + report.skinnedMeshes.length);
            Android.log('Total bones: ' + report.bones.length);
            Android.log('Total vertices: ' + report.totalVertices);
            Android.log('Has skeleton: ' + report.hasSkeleton);

            if (report.bones.length > 0) {
                Android.log('--- BONES ---');
                for (var i = 0; i < Math.min(report.bones.length, 50); i++) {
                    Android.log('  ' + report.bones[i].name);
                }
                if (report.bones.length > 50) {
                    Android.log('  ... and ' + (report.bones.length - 50) + ' more');
                }
            }

            Android.log('--- MESHES ---');
            for (var i = 0; i < report.meshes.length; i++) {
                var m = report.meshes[i];
                Android.log('  ' + m.name + ' (' + m.type + '): ' + m.vertexCount + ' verts, ' + m.morphTargetCount + ' morphs, canModify=' + m.canModifyVertices);
            }

            Android.log('=== END DIAGNOSIS ===');
            return report;
        }

        // Expose functions to Android bridge
        window.diagnoseModel = diagnoseModel;
        window.loadModel = loadModel;
        window.loadTemplateModel = loadTemplateModel;
        window.applyMorphs = applyMorphsImmediate;
        window.animateMorphs = animateMorphsSmooth;
        window.resetMorphs = resetMorphs;
        window.setMorph = setMorph;
        window.getCurrentMorphs = getCurrentMorphs;
        window.getBlendShapeNames = getBlendShapeNames;
        window.setCameraPosition = setCameraPosition;
        window.focusOnRegion = focusOnRegion;
        window.resetCamera = resetCamera;
        window.takeScreenshot = takeScreenshot;
        window.setBackgroundColor = setBackgroundColor;
        window.setWireframe = setWireframe;
        window.setOrbitControls = setOrbitControls;
    </script>
</body>
</html>
